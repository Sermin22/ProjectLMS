# LMS Django Backend
Этот проект — бэкенд-часть системы онлайн-обучения (LMS, Learning Management System).
Он разработан как учебный проект для реализации платформы, где каждый 
желающий может размещать свои курсы и обучающие материалы.

Результатом данного проекта является серверная часть (бэкенд), которая возвращает 
данные в формате JSON. Визуальное отображение данных (frontend) на данном этапе не реализуется.

## Стек технологий
- Python 3.13

- Django

- Django REST Framework (DRF)

## Установка и запуск проекта

1. Клонировать репозиторий:

```
https://github.com/Sermin22/ProjectLMS
```
2. Установить зависимости:

```
poetry install
```
3. Создать базу данных.
4. Создать .env файл в корне проекта и указать необходимые переменные окружения. 
Пример файла - .env_template
5. Выполнить миграции:

```
python manage.py migrate
```

## Запустить сервер разработки:

```
python manage.py runserver
```

## Структура проекта

### Приложение users:
Модель CustomUser (кастомный User):

- Email (используется для авторизации)

- Телефон

- Город

- Аватар

Модель Payments:

- пользователь,
- дата оплаты,
- оплаченный курс,
- оплаченный урок,
- сумма оплаты,
- способ оплаты: наличные или перевод на счет.

Поля пользователь, оплаченный курс и отдельно оплаченный урок
имееют внешние ссылки ForeignKey на соответствующие модели.

Настроена фильтрация для эндпоинта вывода списка платежей с возможностями:

- менять порядок сортировки по дате оплаты,
- фильтровать по курсу или уроку,
- фильтровать по способу оплаты.

### Приложение lms:
Модель Course:
- название;
- превью (картинка);
- описание.

Модель Lesson:
- название;
- описание;
- курс (поле связано через ForeignKey (один ко многим) с моделью Course);
- превью (картинка);
- ссылка на видео.

Модель Subscription:
- пользователь;
- курс.

Модель подписки на обновления курса для пользователя. Модель подписки содержит 
следующие выше поля: «пользователь» (FK на модель пользователя) и «курс» (FK на модель
курса). Реализован эндпоинт для установки подписки пользователя и на ее удаление.

## Функциональность
Реализован CRUD (Create, Read, Update, Delete):

✅ Для модели Course — с помощью ViewSets

✅ Для модели Lesson — с помощью Generic-классов

Каждый эндпоинт протестирован с помощью Postman.

✅ Для модели Lesson - вывод списка уроков с помощью generics.ListAPIView.

Вывод реализован с помощью сериализатора для связанной модели.

Сериализатор выдает и количество уроков курса и информацию по всем урокам курса одновременно.

✅ Для модели CustomUser - с помощью Generic-классов.

Настроено использование JWT-авторизации и закрыт каждый эндпоинт авторизацией.

Эндпоинты для авторизации и регистрации доступны для неавторизованных пользователей.

✅Подключена возможность оплаты курсов через https://stripe.com/docs/api.

✅Проект настроен для работы с Celery и с celery-beat для выполнения периодических задач.

Добавлена асинхронная рассылка писем пользователям об обновлении материалов курса
(уведомление отправляется только в том случае, если курс не обновлялся более четырех часов).

С помощью celery-beat реализована фоновая задача, которая проверяет пользователей 
по дате последнего входа, и если пользователь не заходил более месяца, 
блокирует его, то есть делает неактивным.
Задачу периодическая и по расписанию запланирован проверка в настройках celery-beat рай в день.

## Разграничение прав доступа

Заведена группа модераторов ("moders") и описаны для нее права работы с любыми уроками 
и курсами, но без возможности их удалять и создавать новые. Заложен функционал такой 
проверки в контроллеры.

Описаны права доступа для объектов таким образом, чтобы пользователи, которые не 
входят в группу модераторов, могут видеть, редактировать и удалять только свои курсы 
и уроки.

Загрузить группу из фикстуры можно командой:
```
python manage.py loaddata groups.json
```

## Пагинация

Реализована пагинация с выводом 5-ти элементов на странице с возможностью их
увеличивать максимум до 100.

## Тестирование

Реализованы тесты, которые проверяют корректность работы CRUD уроков и функционал 
работы подписки на обновления курса.
Обработаны возможные варианты взаимодействия с контроллерами пользователей с 
разными правами доступа.

Сохранен результат проверки покрытия тестами.

## Документация к проекту

Подключен и настроен вывод документации для проекта, которую можно посмотреть по ссылкам:
```
/swagger/
/redoc/
```

## Структура репозитория
users/ — приложение для пользователей

lms/ — приложение для курсов и уроков

pyproject.toml — зависимости проекта

.gitignore — исключенные из контроля файлы и папки (например, venv, pycache и др.)

README.md — описание проекта (этот файл)

## Проверка работы

После запуска сервера доступ к API осуществляется через Postman или любой HTTP-клиент.

Примеры эндпоинтов:

/lms/courses/ — список курсов

/lms/courses/{id}/ — детали курса

/lms/lessons/ — список уроков

/lms/lessons/{id}/ — детали урока

## Запуск проекта с помощью Docker Compose на локальной машине

Для удобства запуска и разворачивания проекта используется docker-compose. Это позволяет 
поднять все необходимые сервисы (Django-приложение, база данных, Redis и Celery) 
одной командой.

### Структура docker-compose

В проекте настроены следующие сервисы:

- web — основной Django-бэкенд

- db — PostgreSQL база данных

- redis — брокер сообщений для Celery

- celery — фоновый воркер для асинхронных задач

- celery-beat — планировщик задач для Celery

### Шаги для запуска

1.Убедитесь, что у вас установлен Docker и Docker Compose.

2.Клонируйте репозиторий:
```
git clone https://github.com/Sermin22/ProjectLMS.git
cd ProjectLMS
```
3. Создайте .env файл в корне проекта и укажите необходимые переменные окружения. 
Пример файла - .env_template
4. Запустите проект:
```
docker-compose up -d --build
```
Первый запуск может занять несколько минут, так как будут устанавливаться зависимости, 
применяться миграции и запускаться фоновые процессы.

5. После запуска загрузите тестовые данные (по желанию) и группу модераторов ("moders"):
```
docker-compose exec web python manage.py loaddata groups.json
```
6. После запуска создайте суперюзера (по желанию):
```
docker-compose exec web python manage.py createsuperuser
```

### Проверка работоспособности сервисов

| Сервис          | Описание                     | Проверка                                                                |
| --------------- | ---------------------------- | ----------------------------------------------------------------------- |
| **Django API**  | Основной бэкенд              | Перейдите в браузере на: [http://localhost:8000](http://localhost:8000) |
| **Swagger UI**  | Документация API             | [http://localhost:8000/swagger/](http://localhost:8000/swagger/)        |
| **ReDoc**       | Альтернативная документация  | [http://localhost:8000/redoc/](http://localhost:8000/redoc/)            |
| **PostgreSQL**  | База данных                  | Автоматически подключается к Django                                     |
| **Redis**       | Очередь сообщений для Celery | Проверяется при запуске Celery                                          |
| **Celery**      | Фоновые задачи               | При логировании в терминал видно выполнение задач                       |
| **Celery Beat** | Периодические задачи         | Задачи запускаются согласно расписанию                                  |

**Вы можете также подключиться к контейнеру для отладки:**
```
docker-compose exec web bash
```

### Остановка проекта

Для остановки всех сервисов:
```
docker-compose down
```

Если нужно удалить тома базы данных и кэша:
```
docker-compose down -v
```

## Запуск проекта на удаленном сервере

Для удобства запуска и разворачивания проекта используется docker-compose. Это позволяет 
поднять все необходимые сервисы (Django-приложение, база данных, Redis и Celery) 
одной командой.

### Структура docker-compose

В проекте настроены следующие сервисы:

- web — основной Django-бэкенд

- db — PostgreSQL база данных

- redis — брокер сообщений для Celery

- celery — фоновый воркер для асинхронных задач

- celery-beat — планировщик задач для Celery

### Шаги для запуска

1. Подключитесь к виртуальной машине.

В терминале откройте командную строку и введите команду для подключения:

```
ssh ваш_пользователь@IP_адрес_машины
```
2. Обновление и установка необходимых пакетов.

Когда вы впервые подключаетесь к новой виртуальной машине, важно убедиться, что система 
обновлена и все пакеты находятся в актуальном состоянии. Это помогает предотвратить 
возможные уязвимости и гарантировать стабильность работы сервера.

2.1 Обновление системы.

Откройте терминал и выполните команду для обновления списка пакетов:
```
sudo apt update
```
Затем выполните команду для обновления всех установленных пакетов до их последних 
версий:
```
sudo apt upgrade
```
Эта команда может потребовать подтверждения перед началом обновления. 
Рекомендуем соглашаться с установкой всех обновлений, чтобы убедиться, что 
ваша система работает на последней версии программного обеспечения.

2.2 Установка Docker.

Чтобы установить Docker, воспользуйтесь инструкцией по установке 
с официального сайта: 
```
https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository
```
Добавьте текущего пользователя в группу docker:
```
sudo usermod -aG docker $USER
```
2.3 Настройка файрвола.

Для управления файрволом в Ubuntu используется утилита ufw (Uncomplicated Firewall).

Сначала проверьте состояние файрвола с помощью команды:
```
sudo ufw status
```
Если файрвол отключен, активируйте его:
```
sudo ufw enable
```
Теперь откройте необходимые порты:
Порт 80 для HTTP:
```
sudo ufw allow 80/tcp
```
Порт 443 для HTTPS:
```
sudo ufw allow 443/tcp
```
После открытия портов проверьте настройки файрвола, чтобы убедиться, что правила 
применились:
```
sudo ufw status
```
В результате выполнения этой команды вы должны увидеть, что порты 80 и 443 находятся в состоянии 
ALLOW, что означает разрешение входящих соединений через эти порты.

Чтобы обеспечить доступ к вашему серверу по SSH, необходимо оставить открытым порт 22. 
Для этого выполните следующие шаги:

Откройте порт 22 для SSH:
Введите следующую команду в терминале, чтобы разрешить входящие соединения через порт 22:
```
sudo ufw allow 22/tcp
```
Проверьте настройки файрвола:
После добавления порта, проверьте состояние файрвола снова, чтобы убедиться, 
что порт 22 также открыт:
```
sudo ufw status
```
Ожидаемый результат:

В результате выполнения команды вы должны увидеть, что порт 22 находится в 
состоянии ALLOW наряду с портами 80 и 443. Это означает, что ваш сервер будет 
доступен для SSH-подключений, а также для веб-трафика.

Теперь ваш сервер безопасен и доступен для управления через SSH, а также для 
обработки HTTP и HTTPS запросов.

3. Установка Git
 
3.1. Откройте терминал на сервере и выполните команду:
 ```
sudo apt update
sudo apt install git
```
3.2 Убедитесь, что Git установлен корректно, выполнив команду:
```
git --version
```

4. Выполните команду для клонирования репозитория:

```
git clone https://github.com/Sermin22/ProjectLMS.git
```
5. Перейдите в репозиторий проекта:
```
cd ProjectLMS
```
6. Создайте .env файл в корне проекта и укажите необходимые переменные окружения. 
Пример файла - .env_template
```
nano .env
```

7. Запустите проект:
```
docker-compose up -d --build
```
Первый запуск может занять несколько минут, так как будут устанавливаться зависимости, 
применяться миграции и запускаться фоновые процессы.

8. После запуска проверьта запустились ли контейнеры Docker
```
docker-compose ps
```

9. После запуска загрузите данные группу модераторов ("moders"):
```
docker-compose exec web python manage.py loaddata groups.json
```
6. После запуска создайте суперюзера (по желанию):
```
docker-compose exec web python manage.py createsuperuser
```

### Проверка работоспособности сервисов

| Сервис          | Описание                     | Проверка                                          |
| --------------- | ---------------------------- |---------------------------------------------------|
| **Django API**  | Основной бэкенд              | (http://IP_адрес_машины)                      |
| **Swagger UI**  | Документация API             | (http://IP_адрес_машины/swagger/)                 |
| **ReDoc**       | Альтернативная документация  | (http://IP_адрес_машины/redoc/)                   |
| **PostgreSQL**  | База данных                  | Автоматически подключается к Django               |
| **Redis**       | Очередь сообщений для Celery | Проверяется при запуске Celery                    |
| **Celery**      | Фоновые задачи               | При логировании в терминал видно выполнение задач |
| **Celery Beat** | Периодические задачи         | Задачи запускаются согласно расписанию            |

**Вы можете также подключиться к контейнеру для отладки:**
```
docker-compose exec web bash
```

### Настройка автоматического деплоя

Автоматический деплой позволяет автоматизировать процесс развертывания приложения 
на целевом сервере, что значительно ускоряет выпуск новых версий продукта и 
минимизирует риск ошибок, связанных с ручным развертыванием.

1. Клонируйте репозиторий на локальную машину.
2. Создайте репозиторий на GitHab и свяжите его с локальным проектом.
3. В настройках репозитория GitHab добавьте следующие секреты:

SERVER_IP — IP-адрес вашего сервера.

SSH_USER — имя пользователя для SSH-подключения.

SSH_KEY — приватный SSH-ключ для аутентификации.

DEPLOY_DIR — директория на сервере, где будет размещено приложение.

3. На локальном сервере настройте **systemd**

Создайте unit
```
sudo nano /etc/systemd/system/ProjectLMS.service
```
В файл добавьте следующие настройки:
```
[Unit]
Description=ProjectLMS (docker compose stack)
Requires=docker.service
After=docker.service network.target

[Service]
WorkingDirectory=/home/sm-admin/ProjectLMS

Type=oneshot
RemainAfterExit=yes

ExecStart=/usr/bin/docker compose pull
ExecStart=/usr/bin/docker compose up -d --build --remove-orphans


ExecStop=/usr/bin/docker compose down

TimeoutStartSec=0

StandardOutput=journal
StandardError=journal
SyslogIdentifier=ProjectLMS

[Install]
WantedBy=multi-user.target

```

В проекте создан Django CI/CD Pipeline и теперь при любых изменениях на локальной машине
Workflow запускается при каждом push в репозиторий и Сервер автоматически перезагружает 
приложение при внесении изменений использованием Systemd.

jobs Workflow:

- lint - проверка кода flake8;
- test - тестирование (автоматический запуск тестов);
- deploy - внесение изменений в проект и автоматическая перезагрузка.

### Остановка проекта

Для остановки всех сервисов:
```
docker-compose down
```

Если нужно удалить тома базы данных и кэша:
```
docker-compose down -v
```

## Автор
Sergei, msm2203@mail.ru
```
https://github.com/Sermin22/
```
